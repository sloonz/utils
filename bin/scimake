#!/usr/bin/env python

import sys, os, subprocess

BUILD_SYSTEMS = {}
COMPILERS = {}
EXTENSIONS = {}

class PkgConfigError(Exception):
	pass

def run(cmd, *args):
	args = map(str, [cmd] + list(args))
	p = subprocess.Popen(args, 0, args[0], subprocess.PIPE, subprocess.PIPE, subprocess.STDOUT)
	p.stdin.close()
	
	if p.wait() != 0:
		raise IOError, p.stdout.read().strip()
	
	return p.stdout.read().strip()

class Source:
	_sources = {}
	
	@classmethod
	def getSource(cls, f):
		if f in cls._sources:
			return cls._sources[f]
		else:
			return Source(f)
	
	def __init__(self, file):
		if not file in Source._sources:
			Source._sources[file] = self
		
		self.file = file
		
		self._keywords = {}
		for l in open(file):
			l = l.strip()
			if l.startswith('// ~ ') or l.startswith('# ~ ') and ":" in l:
				key, val = l.split('~ ', 1)[1].split(':', 1)
				if not " " in key.strip():
					self._keywords[key.strip()] = val.strip()
		
		if "master" in self._keywords:
			self._keywords['master'] = Source.getSource(self._keywords['master'])
		if "deps" in self._keywords:
			self._keywords['deps'] = [Source.getSource(f) for f in self._keywords['deps'].split(" ")]
		
		self.lang = self.get('lang') or EXTENSIONS[file.rsplit('.', 1)[1]]
		self.master = self.get('master')
		self.deps = self.get('deps') or []
		self.rules = []
		
		for kw in self._keywords:
			if kw.startswith('rule-'):
				target = kw[len('rule-'):]
				deps, action = self.get(kw).split('//', 1)
				deps, action = deps.strip(), action.strip()
				self.rules.append((target, deps, action))
	
	def get(self, key, default = None):
		try:
			return self._keywords[key]
		except:
			return default
	
	def build_system(self):
		if self.get('master'):
			return self.get('master').build_system()
		return BUILD_SYSTEMS[self.get('system', 0)](additional_rules = self.rules)

#
# Build systems
#	TODO: add gnustep-make
class NativeMakefile(object):
	def __init__(self, **kwargs):
		self._file = kwargs.get('file')
	
	def build(self, source):
		os.execlp("make", "make", "-f", self._file)
	
	def compile(self, source):
		os.execlp("make", "make", "-f", self._file, source.file.rsplit('.', 1)[0] + '.o')
	
	def clean(self, source):
		os.execlp("make", "make", "-f", self._file, "clean")

class Makefile(list):
	def __init__(self, **kwargs):
		list.__init__(self)
		if kwargs.get('additional_rules'):
			self.extend(kwargs['additional_rules'])
	
	@staticmethod
	def _compiler(src):
		return COMPILERS[src.lang][0]
	
	def prepend(self, rule):
		self.insert(0, tuple(rule))
	
	def go(self, target):
		fd = open('SciMakefile', 'w+')
		fd.write("# Automatically generated by scimake, don't edit.\n\n")
		for rule in self:
			fd.write('%s: %s\n\t%s\n\n' % rule)
		fd.close()
		
		print "> make -f SciMakefile ",target
		os.execlp('make', 'make', '-f', 'SciMakefile', target)
	
	def _compile(self, source):
		compiler = self._compiler(source)
		rule = compiler.compile(source)
		self.append(rule)
		
		return rule[0]
	
	def _build(self, source):
		# Compile dependencies
		if source.master:
			return self._build(source.master)
		for dep in source.deps:
			self._compile(dep)
		self._compile(source)
		
		compiler = self._compiler(source)
		rule = compiler.link(source)
		self.prepend(rule)
		
		return rule[0]
	
	def build(self, source):
		self.go(self._build(source))
	
	def compile(self, source):
		self.go(self._compile(source))
	
	def clean(self, source):
		self._build(source)
		toclean = [rule[0] for rule in self]
		self.append(('clean', '', 'rm -f %s' % ' '.join(toclean)))
		self.go('clean')
	
	def run(self, source):
		if source.master:
			return self.run(source.master)
		out = self._build(source)
		self.prepend(('run', out, './%s' % out))
		self.go('run')

# 
# Compilers
#	used by Makefile
class Compiler:
	@staticmethod
	def _pkgconfig(type, src):
		if not src.get('pkg'):
			return ""
		
		try:
			return run('pkg-config', '--' + type, *(src.get('pkg').split(" ")))
		except OSError:
			raise PkgConfigError, "pkg-config not found"
		except IOError, e:
			raise PkgConfigError, e
	
	@classmethod
	def cflags(self, src):
		if src is None: return ""
		my = src.get('cflags') or ""
		master = Compiler.cflags(src.master)
		pkg = self._pkgconfig('cflags', src)
		return " ".join((my, master, pkg))
	
	@classmethod
	def ldflags(self, src):
		if src is None: return ""
		my = src.get('ldflags') or ""
		deps = [Compiler.ldflags(d) for d in src.deps]
		pkg = self._pkgconfig('libs', src)
		return " ".join(deps + [my,pkg])
	

class GCC(Compiler):
	@classmethod
	def _compile_deps(self, file, lang, cflags):
		args = list(self._get_executable(lang).split(' ')) + ['-MM', '-MG', file] + cflags.split()
		try:
			return run(*args).split(':', 1)[1].strip()
		except IOError:
			return file
	
	@classmethod
	def _get_executable(self, lang):
		if lang == "c": return "gcc"
		elif lang == "c++": return "g++"
		else: return "gcc -x %s" % lang
	
	@classmethod
	def _get_ldflags(self, lang):
		if lang == "objective-c": return "-lobjc"
		elif lang == "objective-c++": return "-lobjc -lstdc++"
		elif lang == "c++": return "-lstdc++"
		else: return ""
	
	@staticmethod
	def ldflags(src):
		return Compiler.ldflags(src) + " " + GCC._get_ldflags(src.lang)
	
	@classmethod
	def compile(self, src):
		in_src = src.file
		out_obj = self._obj(src)
		ex = self._get_executable(src.lang)
		cflags = self.cflags(src)
		deps = self._compile_deps(in_src, src.lang, cflags)
		
		return (out_obj, deps, '%s -c %s -o %s %s' % (ex, in_src, out_obj, cflags))
	
	@classmethod
	def link(self, src):
		objects = " ".join([self._obj(s) for s in src.deps] + [self._obj(src)])
		out = src.get('out') or src.file.rsplit('.',1)[0]
		ex = self._get_executable(src.lang)
		
		return (out, objects, 'gcc %s -o %s %s' % (objects, out, self.ldflags(src)))
	
	@staticmethod
	def _obj(src):
		return src.get('object') or src.file.rsplit('.', 1)[0] + '.o'

class GoCompiler(Compiler):
	@classmethod
	def _get_suffix(self):
		if os.environ['GOARCH'] == "amd64":
			return "6"
		elif os.environ['GOARCH'] == "386":
			return "8"
		else:
			raise Exception("not implemented")
	
	@classmethod
	def compile(self, src):
		in_src = src.file
		if src.get('type') == 'cgo':
			if os.environ['GOARCH'] == "amd64":
				num = "6"
				gcflags = "-D_64BIT"
				gcc_cflags = "-m64"
				gcc_ldflags = "-m64"
			elif os.environ['GOARCH'] == "386":
				num = "8"
				gcflags = ""
				gcc_cflags = ""
				gcc_ldflags = ""
			else:
				raise Exception("not implemented")
			
			gcc_cflags += " " + src.get('cgo-cflags', '')
			gcc_ldflags += " " + src.get('cgo-ldflags', '')
			
			base = src.file.rsplit('.', 1)[0]
			cmds = []
			cmds.append("cgo %s" % in_src)
			cmds.append("@sed -i \"s|${GOROOT}/pkg/${GOOS}_${GOARCH}/%s.so|%s.so|\" _cgo_defun.c" % (base, base))
			cmds.append("%(n)sg -o _go_.%(n)s %(b)s.cgo1.go _cgo_gotypes.go" % {'b':base,'n':num})
			cmds.append("%(n)sc -FVw -I\"${GOROOT}\"/src/pkg/runtime %(f)s -o _cgo_defun.%(n)s _cgo_defun.c" % {'f':gcflags,'n':num})
			cmds.append("@gopack grc %(b)s.a _go_.%(n)s _cgo_defun.%(n)s" % {'b':base,'n':num})
			cmds.append("@rm -f %(b)s.cgo1.go _cgo_defun.%(n)s _cgo_defun.c _cgo_gotypes.go _go_.%(n)s _cgo_.o"  % {'b':base,'n':num})
			cmds.append("gcc %(f)s -fPIC -O2 -o %(b)s.cgo2.o -c  %(b)s.cgo2.c" % {'b':base, 'f': gcc_cflags})
			cmds.append("gcc -o %(b)s.so %(b)s.cgo2.o %(f)s -shared -lpthread -lm" % {'b':base, 'f': gcc_ldflags})
			cmds.append("@echo rm -f %(b)s.cgo2.c %(b)s.cgo2.o" % {'b':base})
			cmds.append("@rm -rf _obj")
			
			return (self._obj(src) + " " + base + ".so", in_src, "\n\t".join(cmds))
		else:
			ex = self._get_suffix() + "g"
			cflags = self.cflags(src)
			deps = in_src
			for dep in src.deps:
				deps += " " + self._obj(dep)
			
			return (self._obj(src), deps, '%s -I. %s -o %s %s' % (ex, cflags, self._obj(src), in_src))
	
	@classmethod
	def link(self, src):
		objects = " ".join([self._obj(s) for s in src.deps] + [self._obj(src)])
		out = src.get('out') or src.file.rsplit('.',1)[0]
		ex = self._get_suffix() + "l"
		
		return (out, objects, '%s -L. %s -o %s %s' % (ex, self.ldflags(src), out, objects))
	
	@classmethod
	def _obj(self, src):
		if src.get('type') == 'cgo':
			base = src.file.rsplit('.', 1)[0]
			return base + ".a"
		else:
			return src.get('object') or src.file.rsplit('.', 1)[0] + '.' + self._get_suffix()

#
# Fill constants
#
BUILD_SYSTEMS[0] = Makefile
BUILD_SYSTEMS['make'] = Makefile

COMPILERS['c'] = (GCC,)
COMPILERS['c++'] = (GCC,)
COMPILERS['objective-c'] = (GCC,)
COMPILERS['objective-c++'] = (GCC,)
COMPILERS['go'] = (GoCompiler,)

EXTENSIONS['h'] = EXTENSIONS['c'] = 'c'
EXTENSIONS['hpp'] = EXTENSIONS['hxx'] = EXTENSIONS['hh'] = EXTENSIONS['cc'] = EXTENSIONS['cpp'] = EXTENSIONS['cxx'] = 'c++'
EXTENSIONS['m'] = 'objective-c'
EXTENSIONS['mm'] = EXTENSIONS['M'] = 'objective-c++'
EXTENSIONS['go'] = 'go'

if __name__ == "__main__":
	target, action = sys.argv[1:]
	source = Source(target)
	
	bs = None
	for f in ('Makefile', 'makefile', 'GNUmakefile', 'GNUMakefile'):
		if os.path.exists(f):
			bs = NativeMakefile(file = f)
			break
	else:
		bs = source.build_system()
	
	getattr(bs, action)(source)
